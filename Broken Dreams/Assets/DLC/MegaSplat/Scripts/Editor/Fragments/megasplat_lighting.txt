 
            UnityLight AdditiveLight (half3 normalWorld, half3 lightDir, half atten)
            {
               UnityLight l;

               l.color = _LightColor0.rgb;
               l.dir = lightDir;
               #ifndef USING_DIRECTIONAL_LIGHT
                  l.dir = normalize(l.dir);
               #endif
               l.ndotl = LambertTerm (normalWorld, l.dir);

               // shadow the light
               l.color *= atten;
               return l;
            }

            UnityLight MainLight (half3 normalWorld)
            {
               UnityLight l;
               #ifdef LIGHTMAP_OFF
                  
                  l.color = _LightColor0.rgb;
                  l.dir = _WorldSpaceLightPos0.xyz;
                  l.ndotl = LambertTerm (normalWorld, l.dir);
               #else
                  // no light specified by the engine
                  // analytical light might be extracted from Lightmap data later on in the shader depending on the Lightmap type
                  l.color = half3(0.f, 0.f, 0.f);
                  l.ndotl  = 0.f;
                  l.dir = half3(0.f, 0.f, 0.f);
               #endif

               return l;
            }

            inline half4 VertexGIForward(float2 uv1, float2 uv2, float3 posWorld, half3 normalWorld)
            {
               half4 ambientOrLightmapUV = 0;
               // Static lightmaps
               #ifdef LIGHTMAP_ON
                  ambientOrLightmapUV.xy = uv1.xy * unity_LightmapST.xy + unity_LightmapST.zw;
                  ambientOrLightmapUV.zw = 0;
               // Sample light probe for Dynamic objects only (no static or dynamic lightmaps)
               #elif UNITY_SHOULD_SAMPLE_SH
                  #ifdef VERTEXLIGHT_ON
                     // Approximated illumination from non-important point lights
                     ambientOrLightmapUV.rgb = Shade4PointLights (
                        unity_4LightPosX0, unity_4LightPosY0, unity_4LightPosZ0,
                        unity_LightColor[0].rgb, unity_LightColor[1].rgb, unity_LightColor[2].rgb, unity_LightColor[3].rgb,
                        unity_4LightAtten0, posWorld, normalWorld);
                  #endif

                  ambientOrLightmapUV.rgb = ShadeSHPerVertex (normalWorld, ambientOrLightmapUV.rgb);     
               #endif

               #ifdef DYNAMICLIGHTMAP_ON
                  ambientOrLightmapUV.zw = uv2.xy * unity_DynamicLightmapST.xy + unity_DynamicLightmapST.zw;
               #endif

               return ambientOrLightmapUV;
            }

            void LightPBRDeferred(VertexOutput i, half3 albedo, half3 normalDirection, half3 emission, half smoothness, half metallic,
                           half occlusion, half alpha, float3 viewDir,
                           inout half3 indirectDiffuse, inout half3 indirectSpecular, inout half3 diffuseColor, inout half3 specularColor)
            {
               #if _PASSDEFERRED
               half lightAtten = 1;
               half roughness = 1 - smoothness;

               UnityLight light = MainLight (normalDirection);

               UnityGIInput d;
               UNITY_INITIALIZE_OUTPUT(UnityGIInput, d);
               d.light = light;
               d.worldPos = i.posWorld.xyz;
               d.worldViewDir = viewDir;
               d.atten = lightAtten;
               #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
                  d.ambient = 0;
                  d.lightmapUV = i.ambientOrLightmapUV;
               #else
                  d.ambient = i.ambientOrLightmapUV.rgb;
                  d.lightmapUV = 0;
               #endif
               d.boxMax[0] = unity_SpecCube0_BoxMax;
               d.boxMin[0] = unity_SpecCube0_BoxMin;
               d.probePosition[0] = unity_SpecCube0_ProbePosition;
               d.probeHDR[0] = unity_SpecCube0_HDR;
               d.boxMax[1] = unity_SpecCube1_BoxMax;
               d.boxMin[1] = unity_SpecCube1_BoxMin;
               d.probePosition[1] = unity_SpecCube1_ProbePosition;
               d.probeHDR[1] = unity_SpecCube1_HDR;

               UnityGI gi = UnityGlobalIllumination(d, occlusion, 1.0 - smoothness, normalDirection );

               specularColor = metallic.xxx;
               float specularMonochrome;
               diffuseColor = DiffuseAndSpecularFromMetallic( albedo, specularColor, specularColor, specularMonochrome );

               indirectSpecular = (gi.indirect.specular);
               float NdotV = max(0.0,dot( normalDirection, viewDir ));
               specularMonochrome = 1.0-specularMonochrome;
               half grazingTerm = saturate( smoothness + specularMonochrome );
               indirectSpecular *= FresnelLerp (specularColor, grazingTerm, NdotV);
               indirectDiffuse = half3(0,0,0);
               indirectDiffuse += gi.indirect.diffuse;
               indirectDiffuse *= occlusion;

               #endif
            }


            half4 LightPBR(VertexOutput i, half3 albedo, half3 normalDirection, half3 emission, half smoothness, half metallic, 
                            half occlusion, half alpha, float3 viewDir, float4 ambientOrLightmapUV)
            {
                

                #if _PASSFORWARDBASE
                half lightAtten = LIGHT_ATTENUATION(i);
                half roughness = 1 - smoothness;

                #if _RAMPLIGHTING
                {
                   float3 lightDirection = normalize(_WorldSpaceLightPos0.xyz);
                   half4 ramped = half4(DoLightingRamp(albedo * occlusion, normalDirection, emission, lightDirection, lightAtten), 1);
                   UNITY_APPLY_FOG(i.fogCoord, ramped);
                   return ramped;
                }
                #endif

                UnityLight light = MainLight (normalDirection);

                UnityGIInput d;
                d.light = light;
                d.worldPos = i.posWorld.xyz;
                d.worldViewDir = viewDir;
                d.atten = lightAtten;
                #if LIGHTMAP_ON || DYNAMICLIGHTMAP_ON
                    d.ambient = 0;
                    d.lightmapUV = i.ambientOrLightmapUV;
                #else
                    d.ambient = i.ambientOrLightmapUV;
                    d.lightmapUV = 0;
                #endif

                d.boxMax[0] = unity_SpecCube0_BoxMax;
                d.boxMin[0] = unity_SpecCube0_BoxMin;
                d.probePosition[0] = unity_SpecCube0_ProbePosition;
                d.probeHDR[0] = unity_SpecCube0_HDR;
                d.boxMax[1] = unity_SpecCube1_BoxMax;
                d.boxMin[1] = unity_SpecCube1_BoxMin;
                d.probePosition[1] = unity_SpecCube1_ProbePosition;
                d.probeHDR[1] = unity_SpecCube1_HDR;
                Unity_GlossyEnvironmentData ugls_en_data;
                ugls_en_data.roughness = roughness;
                ugls_en_data.reflUVW = reflect( -viewDir, normalDirection );
                UnityGI gi = UnityGlobalIllumination(d, occlusion, normalDirection, ugls_en_data );

                half3 specularColor = metallic.xxx;
                half oneMinusReflectivity;
                half3 diffuseColor = albedo;
                diffuseColor = DiffuseAndSpecularFromMetallic( albedo, specularColor, specularColor, oneMinusReflectivity );
                

                half4 c = UNITY_BRDF_PBS (diffuseColor, specularColor, oneMinusReflectivity, smoothness, normalDirection, viewDir, gi.light, gi.indirect);
                c.rgb += UNITY_BRDF_GI (diffuseColor, specularColor, oneMinusReflectivity, smoothness, normalDirection, viewDir, occlusion, gi);
                c.rgb += emission;
                c.a = alpha;
                UNITY_APPLY_FOG(i.fogCoord, c.rgb);
                return c;

                #elif _PASSFORWARDADD
                half lightAtten = LIGHT_ATTENUATION(i);
                half roughness = 1 - smoothness;

                #if _RAMPLIGHTING
                {
                   float3 lightDirection = normalize(lerp(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz - i.posWorld.xyz,_WorldSpaceLightPos0.w));
                   half4 ramped = half4(DoLightingRamp(albedo * occlusion, normalDirection, emission, lightDirection, lightAtten), 1);
                   UNITY_APPLY_FOG_COLOR(i.fogCoord, ramped.rgb, half4(0,0,0,0));
                   return ramped;
                }
                #endif

                half3 specularColor = metallic.xxx;
                half oneMinusReflectivity;
                half3 diffuseColor = albedo;
                diffuseColor = DiffuseAndSpecularFromMetallic( diffuseColor, specularColor, specularColor, oneMinusReflectivity );

                UnityLight light = AdditiveLight (normalDirection, normalDirection, lightAtten);
                UnityIndirect noIndirect = (UnityIndirect)0;
                noIndirect.diffuse = 0;
                noIndirect.specular = 0;

                half4 c = UNITY_BRDF_PBS (diffuseColor, specularColor, oneMinusReflectivity, smoothness, normalDirection, viewDir, light, noIndirect);
   
                UNITY_APPLY_FOG_COLOR(i.fogCoord, c.rgb, half4(0,0,0,0)); // fog towards black in additive pass
                c.a = alpha;
                return c;

                #endif
                return half4(1, 1, 0, 0);
            }